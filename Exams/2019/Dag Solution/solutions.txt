1 --------------------------------------------------------------------------------

1)
// the old:
// let iconEx1 = Write(Prim("<",CstI 7,FromTo(1,10)))
let iconEx1 = Every(Write(Prim("<",CstI 7,FromTo(1,10))))
> run iconEx1;;
8 9 10 val it : value = Int 0

2)
// old:
//let let iconEx2 = Every(Write(And(FromTo(1,4), And(Write (CstS "\n"),FromTo(1,4)))))
let iconEx2 = Every(Write(Prim("*",FromTo(1,4), And(Write (CstS "\n"),FromTo(1,4)))))
> run iconEx2;;
 1 2 3 4
 2 4 6 8
 3 6 9 12
 4 8 12 16 val it : value = Int 0

// every ( write ( (1 to 4) * ( (write "\n") + ( 1 to 4))))

3)

| Find(pat,str) ->
  let rec findIndex (i:int) =
    let index = str.IndexOf(pat,i) 
    if index <> -1
    then
      cont (Int index) (fun () -> findIndex (index+1))
    else
      econt ()
  findIndex 0   

4)

> run (Every(Write(Find(" ",str))));;
2 8 10 13 19 23 val it : value = Int 0

> run (Every(Write(Find("p",str))));;
val it : value = Int 0

> run (Every(Write(Find("e","hej"))));;
1 val it : value = Int 0

> run (Every(Write(Find("e",""))));;
val it : value = Int 0

5)

> run (Every(Write(Find("e",str))));;
5 7 16 18 22 29 val it : value = Int 0

> run (Every(Write(Prim("<",CstI 10,Find("e",str)))));;
16 18 22 29 val it : value = Int 0

2 --------------------------------------------------------------------------------

1)
let x = { } in x end (* ex1 *)
Let ("x",Record [],Var "x")

let x = {field1 = 32} in x.field1 end (* ex2 *)
Let ("x",Record [("field1", CstI 32)],Field (Var "x","field1"))

let x = {field1 = 32; field2 = 33} in x end (* ex3 *)
Let ("x",Record [("field1", CstI 32);("field2", CstI 33)],Var "x")

let x = {field1 = 32; field2 = 33} in x.field1 end (* ex4 *)
Let ("x",Record [("field1", CstI 32);("field2", CstI 33)],Field (Var "x","field1"))

let x = {field1 = 32; field2 = 33} in x.field1+x.field2 end (* ex5 *)
Let ("x",Record [("field1", CstI 32);("field2", CstI 33)],Prim("+",Field (Var "x","field1"),Field (Var "x","field1")))

2)

> let ex1 = fromString("let x = { } in x end");;
val ex1 : Absyn.expr = Let ("x",Record [],Var "x")

> let ex2 = fromString("let x = {field1 = 32} in x.field1 end");;
val ex2 : Absyn.expr = Let ("x",Record [("field1", CstI 32)],Field (Var "x","field1"))

> let ex3 = fromString("let x = {field1 = 32; field2 = 33} in x end");;
val ex3 : Absyn.expr = Let ("x",Record [("field1", CstI 32); ("field2", CstI 33)],Var "x")

> let ex4 = fromString("let x = {field1 = 32; field2 = 33} in x.field1 end");;
val ex4 : Absyn.expr =
  Let
    ("x",Record [("field1", CstI 32); ("field2", CstI 33)],
     Field (Var "x","field1"))

> let ex5 = fromString("let x = {field1 = 32; field2 = 33} in x.field1+x.field2 end");;
val ex5 : Absyn.expr =
  Let
    ("x",Record [("field1", CstI 32); ("field2", CstI 33)],
     Prim ("+",Field (Var "x","field1"),Field (Var "x","field2")))


3 --------------------------------------------------------------------------------


2)

type value =
  | Int of int
  | RecordV of (string * value) list
  | Closure of string * string * expr * value env

let rec eval (e : expr) (env : value env) : value =
  match e with
  | ...
  | Record l -> RecordV(List.map (fun (a,b) -> (a,eval b env) ) l)
      | Field(e,s) -> 
        let v = eval e env
        match v with
        | RecordV l -> lookup l s 
        | _ -> failwith "Not a record"
  | ...    

3)
> run (Let ("x",Record [("field1", CstI 32);("field1",CstI 33)],Field (Var "x","field1")));;
val it : HigherFun.value = Int 32

og så lidt flere her.


4 --------------------------------------------------------------------------------




5 --------------------------------------------------------------------------------


1)

The stackframe 
[ 4 -999 42 42 42 42 42 2 5 | 125 2 2 0 ]
             stackframeskift^     | sp^
                                bp^  


2)

Resultatet bliver ikke som forventet, da "optimeringerne" i Contcomp.fs gør at `printArray(a)` bliver lavet til et TCall (et tail call), som overskriver den gamle stackframe, hvilket resulterer i at 42'tallerne bliver overskrevet.

